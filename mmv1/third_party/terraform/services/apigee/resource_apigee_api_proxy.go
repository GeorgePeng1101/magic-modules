// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package apigee

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"google.golang.org/api/googleapi"
)

func ResourceApigeeApiProxy() *schema.Resource {
	return &schema.Resource{
		Create: resourceApigeeApiProxyCreate,
		Read:   resourceApigeeApiProxyRead,
		Update: resourceApigeeApiProxyUpdate,
		Delete: resourceApigeeApiProxyDelete,

		Importer: &schema.ResourceImporter{
			State: resourceApigeeApiProxyImport,
		},

		CustomizeDiff: customdiff.All(
			/*
				If any of the config_bundle, detect_md5hash or md5hash is changed,
				then an update is expected, so we tell Terraform core to expect update on meta_data,
				latest_revision_id and revision
			*/

			customdiff.ComputedIf("meta_data", apigeeApiProxyDetectBundleUpdate),
			customdiff.ComputedIf("latest_revision_id", apigeeApiProxyDetectBundleUpdate),
			customdiff.ComputedIf("revision", apigeeApiProxyDetectBundleUpdate),
		),

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"org_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `The Apigee Organization associated with the Apigee instance,
in the format 'organizations/{{org_name}}'.`,
			},
			"labels": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `User labels applied to this API Proxy.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"read_only": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Output only. Whether this proxy is read-only. A read-only proxy cannot have new revisions created through calls to apis.create. A proxy is read-only if it was generated by an archive.`,
			},
			"api_proxy_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The type of the API proxy.`,
			},
			"latest_revision_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The id of the most recently created revision for this api proxy.`,
			},
			"meta_data": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. Metadata describing the API proxy.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"created_at": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Time at which the API proxy was created, in milliseconds since epoch.`,
						},
						"last_modified_at": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `An integer value (int64 format).`,
						},
						"sub_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The type of entity described.`,
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. Name of the API proxy.`,
			},
			"revision": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Output only. List of revisions defined for the API proxy.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"config_bundle": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Path to the config zip bundle`,
			},
			"md5hash": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Base 64 MD5 hash of the uploaded config bundle.`,
			},
			"detect_md5hash": {
				Type:        schema.TypeString,
				Optional:    true,
				Default:     "Different Hash",
				Description: `A hash of local config bundle in string, user needs to use a Terraform Hash function of their choice. A change in hash will trigger an update.`,
				DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool {
					localMd5Hash := ""
					if config_bundle, ok := d.GetOkExists("config_bundle"); ok {
						localMd5Hash = tpgresource.GetFileMd5Hash(config_bundle.(string))
					}
					if localMd5Hash == "" {
						return false
					}

					// `old` is the md5 hash we speculated from server responses,
					// when apply responded with succeed, hash is set to the hash of uploaded bundle
					if old != localMd5Hash {
						return false
					}

					return true
				},
			},
		},
		UseJSONNumber: true,
	}
}

func resourceApigeeApiProxyCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	var file *os.File
	var localMd5Hash string
	if configBundlePath, ok := d.GetOk("config_bundle"); ok {
		var err error
		file, err = os.Open(configBundlePath.(string))
		if err != nil {
			return err
		}
		localMd5Hash = tpgresource.GetFileMd5Hash(configBundlePath.(string))
	} else {
		return fmt.Errorf("Error, \"config_bundle\" must be specified")
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ApigeeBasePath}}organizations/{{org_id}}/apis?name={{name}}&action=import")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	log.Printf("[DEBUG] resourceApigeeApiProxyCreate, url=, 	%s", url)
	res, err := sendRequestRawBodyWithTimeout(config, "POST", billingProject, url, userAgent, file, "application/octet-stream", d.Timeout(schema.TimeoutCreate))

	log.Printf("[DEBUG] sendRequestRawBodyWithTimeout Done")
	if err != nil {
		return fmt.Errorf("Error creating ApiProxy: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "organizations/{{org_id}}/apis/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)
	log.Printf("[DEBUG] create d.SetId done, id = %s", id)

	log.Printf("[DEBUG] Finished creating API %q: %#v", d.Id(), res)

	if resourceApigeeApiProxyRead(d, meta) != nil {
		return fmt.Errorf("Error reading API at end of Create: %s", err)
	}
	d.Set("md5hash", localMd5Hash)
	d.Set("detect_md5hash", localMd5Hash)
	return nil
}

func resourceApigeeApiProxyRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ApigeeBasePath}}organizations/{{org_id}}/apis/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}
	log.Printf("[DEBUG] resourceApigeeApiProxyRead sendRequest")
	log.Printf("[DEBUG] resourceApigeeApiProxyRead, url=, 	%s", url)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ApigeeApiProxy %q", d.Id()))
	}
	log.Printf("[DEBUG] resourceApigeeApiProxyRead sendRequest completed")
	previousLastModifiedAt := getApigeeApiProxyLastModifiedAt(d)
	if err := d.Set("meta_data", flattenApigeeApiProxyMetaData(res["metaData"], d, config)); err != nil {
		return fmt.Errorf("Error reading ApiProxy: %s", err)
	}
	currentLastModifiedAt := getApigeeApiProxyLastModifiedAt(d)
	if err := d.Set("name", flattenApigeeApiProxyName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ApiProxy: %s", err)
	}
	if err := d.Set("revision", flattenApigeeApiProxyRevision(res["revision"], d, config)); err != nil {
		return fmt.Errorf("Error reading ApiProxy: %s", err)
	}
	if err := d.Set("latest_revision_id", flattenApigeeApiProxyLatestRevisionId(res["latestRevisionId"], d, config)); err != nil {
		return fmt.Errorf("Error reading ApiProxy: %s", err)
	}

	//setting hash to suggest update
	if previousLastModifiedAt != currentLastModifiedAt {
		d.Set("md5hash", "UNKNOWN")
		d.Set("detect_md5hash", "UNKNOWN")
	}
	return nil
}

func resourceApigeeApiProxyUpdate(d *schema.ResourceData, meta interface{}) error {
	//For how ApiProxy api is implemented, just treat an update as create, when the name is same, it will create a new revision
	return resourceApigeeApiProxyCreate(d, meta)
}

func resourceApigeeApiProxyDelete(d *schema.ResourceData, meta interface{}) error {
	log.Printf("[DEBUG] resourceApigeeApiProxyDelete")
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := tpgresource.ReplaceVars(d, config, "{{ApigeeBasePath}}organizations/{{org_id}}/ApiProxys/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting ApiProxy %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "ApiProxy")
	}

	log.Printf("[DEBUG] Finished deleting ApiProxy %q: %#v", d.Id(), res)
	return nil
}

func resourceApigeeApiProxyImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)

	// current import_formats cannot import fields with forward slashes in their value
	if err := tpgresource.ParseImportId([]string{
		"organizations/(?P<org_id>.+)/apis/(?P<name>.+)",
		"(?P<org_id>.+)/(?P<name>.+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "organizations/{{org_id}}/apis/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenApigeeApiProxyMetaData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["created_at"] =
		flattenApigeeApiProxyMetaDataCreatedAt(original["createdAt"], d, config)
	transformed["last_modified_at"] =
		flattenApigeeApiProxyMetaDataLastModifiedAt(original["lastModifiedAt"], d, config)
	transformed["sub_type"] =
		flattenApigeeApiProxyMetaDataSubType(original["subType"], d, config)
	return []interface{}{transformed}
}
func flattenApigeeApiProxyMetaDataCreatedAt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyMetaDataLastModifiedAt(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyMetaDataSubType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyRevision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyLatestRevisionId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyReadOnly(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenApigeeApiProxyApiProxyType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandApigeeApiProxyLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandApigeeApiProxyReadOnly(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

// sendRequestRawBodyWithTimeout is derived from sendRequestWithTimeout with direct pass through of request body
func sendRequestRawBodyWithTimeout(config *transport_tpg.Config, method, project, rawurl, userAgent string, body io.Reader, contentType string, timeout time.Duration, errorRetryPredicates ...transport_tpg.RetryErrorPredicateFunc) (map[string]interface{}, error) {
	log.Printf("[DEBUG] sendRequestRawBodyWithTimeout start")
	reqHeaders := make(http.Header)
	reqHeaders.Set("User-Agent", userAgent)
	reqHeaders.Set("Content-Type", contentType)

	if config.UserProjectOverride && project != "" {
		// Pass the project into this fn instead of parsing it from the URL because
		// both project names and URLs can have colons in them.
		reqHeaders.Set("X-Goog-User-Project", project)
	}

	if timeout == 0 {
		timeout = time.Duration(1) * time.Minute
	}

	var res *http.Response

	log.Printf("[DEBUG] sendRequestRawBodyWithTimeout sending request")

	err := transport_tpg.Retry(transport_tpg.RetryOptions{
		RetryFunc: func() error {
			req, err := http.NewRequest(method, rawurl, body)
			if err != nil {
				return err
			}

			req.Header = reqHeaders
			res, err = config.Client.Do(req)
			if err != nil {
				return err
			}

			if err := googleapi.CheckResponse(res); err != nil {
				googleapi.CloseBody(res)
				return err
			}

			return nil
		},
		Timeout:              timeout,
		ErrorRetryPredicates: errorRetryPredicates,
	})
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, fmt.Errorf("Unable to parse server response. This is most likely a terraform problem, please file a bug at https://github.com/hashicorp/terraform-provider-google/issues.")
	}

	// The defer call must be made outside of the retryFunc otherwise it's closed too soon.
	defer googleapi.CloseBody(res)

	// 204 responses will have no body, so we're going to error with "EOF" if we
	// try to parse it. Instead, we can just return nil.
	if res.StatusCode == 204 {
		return nil, nil
	}
	result := make(map[string]interface{})
	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return nil, err
	}
	log.Printf("[DEBUG] sendRequestRawBodyWithTimeout returning")
	return result, nil
}

func apigeeApiProxyDetectBundleUpdate(_ context.Context, diff *schema.ResourceDiff, v interface{}) bool {
	tmp, _ := diff.GetChange("detect_md5hash")
	oldBundleHash := tmp.(string)
	currentBundleHash := ""
	if config_bundle, ok := diff.GetOkExists("config_bundle"); ok {
		currentBundleHash = tpgresource.GetFileMd5Hash(config_bundle.(string))
	}
	log.Printf("[DEBUG] apigeeApiProxyDetectUpdate detect_md5hash: %s -> %s", oldBundleHash, currentBundleHash)

	if oldBundleHash != currentBundleHash {
		return true
	}
	return diff.HasChange("config_bundle") || diff.HasChange("md5hash")
}

func getApigeeApiProxyLastModifiedAt(d *schema.ResourceData) string {

	metaDataRaw := d.Get("meta_data").([]interface{})
	if len(metaDataRaw) != 1 {
		//in Terraform Schema, a nest in object is implemented as an array of length one, even if it's technically an object
		return "UNKNOWN"
	}
	metaData := metaDataRaw[0].(map[string]interface{})
	if metaData == nil {
		return "UNKNOWN"
	}
	lastModifiedAt := metaData["last_modified_at"].(string)
	if lastModifiedAt == "" {
		return "UNKNOWN"
	}
	return lastModifiedAt
}
